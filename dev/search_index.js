var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = AwkwardArray","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"functions/#Built-in-functions","page":"Functions","title":"Built-in functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Every Content subclass has the following built-in functions:","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.length\nBase.size (1-tuple of length)\nBase.firstindex, Base.lastindex(1-based or inherited from its index)\nBase.getindex select by Int(single item), UnitRange{Int}(slice), and Symbol(record field)\nBase.iterate\nBase.:(==) (equality defined by values: a ListOffsetArray and a ListArray may be considered the same)\nBase.push!\nBase.append!\nBase.show","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.length\nBase.size\nBase.firstindex\nBase.lastindex\nBase.getindex\nBase.iterate\nBase.eltype\nBase.:(==)\nBase.push!\nBase.append!\nBase.show\nBase.keys","category":"page"},{"location":"functions/#Base.length","page":"Functions","title":"Base.length","text":"Base.length(parameters::Parameters)\n\n\n\n\n\nBase.length(layout::PrimitiveArray)\n\n\n\n\n\nBase.length(layout::EmptyArray)\n\n\n\n\n\nBase.length(layout::ListOffsetArray)\n\nLength of a ListOffsetArray.\n\n\n\n\n\nBase.length(layout::ListArray)\n\nLength of a ListArray.\n\n\n\n\n\nBase.length(layout::RegularArray)\n\nLength of a RegularArray.\n\n\n\n\n\nBase.length(layout::RecordArray)\n\n\n\n\n\nBase.length(layout::TupleArray)\n\n\n\n\n\nBase.length(layout::IndexedArray)\n\n\n\n\n\nBase.length(layout::IndexedOptionArray)\n\n\n\n\n\nBase.length(layout::ByteMaskedArray)\n\n\n\n\n\nBase.length(layout::BitMaskedArray)\n\n\n\n\n\nBase.length(layout::UnmaskedArray)\n\n\n\n\n\nBase.length(layout::UnionArray)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.size","page":"Functions","title":"Base.size","text":"Treat instances of Content as if they are one-dimensional arrays.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.firstindex","page":"Functions","title":"Base.firstindex","text":"Base.firstindex(layout::PrimitiveArray)\n\n\n\n\n\nBase.firstindex(layout::EmptyArray)\n\n\n\n\n\nBase.firstindex(layout::ListOffsetArray)\n\nFirst index of a ListOffsetArray offsets.\n\n\n\n\n\nBase.firstindex(layout::ListArray)\n\nFirst index of a ListArray starts.\n\n\n\n\n\nBase.firstindex(layout::RegularArray)\n\nFirst index of a RegularArray is always 1.\n\n\n\n\n\nBase.firstindex(layout::RecordArray)\n\n\n\n\n\nBase.firstindex(layout::TupleArray)\n\n\n\n\n\nBase.firstindex(layout::IndexedArray)\n\n\n\n\n\nBase.firstindex(layout::IndexedOptionArray)\n\n\n\n\n\nBase.firstindex(layout::ByteMaskedArray)\n\n\n\n\n\nBase.firstindex(layout::BitMaskedArray)\n\n\n\n\n\nBase.firstindex(layout::UnmaskedArray)\n\n\n\n\n\nBase.firstindex(layout::UnionArray)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.lastindex","page":"Functions","title":"Base.lastindex","text":"Base.lastindex(layout::PrimitiveArray)\n\n\n\n\n\nBase.lastindex(layout::EmptyArray)\n\n\n\n\n\nBase.lastindex(layout::ListOffsetArray)\n\nLast index of a ListOffsetArray offsets.\n\n\n\n\n\nBase.lastindex(layout::ListArray)\n\nLast index of a ListArray starts.\n\n\n\n\n\nBase.lastindex(layout::RegularArray)\n\nLast index of a RegularArray.\n\n\n\n\n\nBase.lastindex(layout::RecordArray)\n\n\n\n\n\nBase.lastindex(layout::TupleArray)\n\n\n\n\n\nBase.lastindex(layout::IndexedArray)\n\n\n\n\n\nBase.lastindex(layout::IndexedOptionArray)\n\n\n\n\n\nBase.lastindex(layout::ByteMaskedArray)\n\n\n\n\n\nBase.lastindex(layout::BitMaskedArray)\n\n\n\n\n\nBase.lastindex(layout::UnmaskedArray)\n\n\n\n\n\nBase.lastindex(layout::UnionArray)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.getindex","page":"Functions","title":"Base.getindex","text":"Base.getindex(layout::PrimitiveArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::PrimitiveArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::EmptyArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::EmptyArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::ListOffsetArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::ListOffsetArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::ListOffsetArray, f::Symbol)\n\n\n\n\n\nBase.getindex(layout::ListArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::ListArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::ListArray, f::Symbol)\n\n\n\n\n\nBase.getindex(layout::RegularArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::RegularArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::RegularArray, f::Symbol)\n\n\n\n\n\nBase.getindex(\n    layout::ListOffsetArray{INDEX,PrimitiveArray{UInt8,BUFFER,:char},:string},\n    i::Int,\n) where {INDEX<:IndexBig,BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nBase.getindex(\n    layout::ListArray{INDEX,PrimitiveArray{UInt8,BUFFER,:char},:string},\n    i::Int,\n) where {INDEX<:IndexBig,BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nBase.getindex(\n    layout::RegularArray{PrimitiveArray{UInt8,BUFFER,:char},:string},\n    i::Int,\n) where {BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nBase.getindex(\n    layout::ListOffsetArray{INDEX,PrimitiveArray{UInt8,BUFFER,:byte},:bytestring},\n    i::Int,\n) where {INDEX<:IndexBig,BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nBase.getindex(\n    layout::ListArray{INDEX,PrimitiveArray{UInt8,BUFFER,:byte},:bytestring},\n    i::Int,\n) where {INDEX<:IndexBig,BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nBase.getindex(\n    layout::RegularArray{PrimitiveArray{UInt8,BUFFER,:byte},:bytestring},\n    i::Int,\n) where {BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nBase.getindex(\n    layout::RecordArray{FIELDS,CONTENTS,BEHAVIOR},\n    i::Int,\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR}\n\n\n\n\n\nBase.getindex(\n    layout::RecordArray{FIELDS,CONTENTS,BEHAVIOR},\n    r::UnitRange{Int},\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR}\n\n\n\n\n\nBase.getindex(\n    layout::RecordArray{FIELDS,CONTENTS,BEHAVIOR},\n    f::Symbol,\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR}\n\n\n\n\n\nBase.getindex(\n    layout::Record{FIELDS,CONTENTS},\n    f::Symbol,\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\nBase.getindex(\n    layout::TupleArray{CONTENTS,BEHAVIOR},\n    i::Int,\n) where {CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR}\n\n\n\n\n\nBase.getindex(\n    layout::TupleArray{CONTENTS,BEHAVIOR},\n    r::UnitRange{Int},\n) where {VALUES<:Content,CONTENTS<:Base.Tuple{VALUES},BEHAVIOR}\n\n\n\n\n\nBase.getindex(\n    layout::SlotRecord{CONTENTS},\n    f::Int64,\n) where {CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\nBase.getindex(layout::IndexedArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::IndexedArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::IndexedArray, f::Symbol)\n\n\n\n\n\nBase.getindex(layout::IndexedOptionArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::IndexedOptionArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::IndexedOptionArray, f::Symbol)\n\n\n\n\n\nBase.getindex(layout::ByteMaskedArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::ByteMaskedArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::ByteMaskedArray, f::Symbol)\n\n\n\n\n\nBase.getindex(layout::BitMaskedArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::BitMaskedArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::BitMaskedArray, f::Symbol)\n\n\n\n\n\nBase.getindex(layout::UnmaskedArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::UnmaskedArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::UnmaskedArray, f::Symbol)\n\n\n\n\n\nBase.getindex(layout::UnionArray, i::Int)\n\n\n\n\n\nBase.getindex(layout::UnionArray, r::UnitRange{Int})\n\n\n\n\n\nBase.getindex(layout::UnionArray, f::Symbol)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.iterate","page":"Functions","title":"Base.iterate","text":"Base.iterate(layout::Content)\n\nEnable the use of Julia's iteration protocol on instances of Content type.\n\nExamples\n\n# Assuming Content is defined and an instance is created\nfor element in layout_instance\n    println(element)\nend\n\nInitialization: The iteration process starts by calling Base.iterate(layout) with the collection layout as the only argument. This should return  the first element and the initial state.\n\n\n\n\n\nBase.iterate(layout::Content, state)\n\nIteration: The iteration continues by repeatedly calling  Base.iterate(layout, state) with the collection and the current state.  This returns the next element and the next state until it returns  nothing, indicating the end of the iteration.\n\nParameters\n\nlayout::Content: This specifies that the function operates on an  instance of the type Content.\n\nstate: This represents the current state of the iteration,  typically an index or position in the collection.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.eltype","page":"Functions","title":"Base.eltype","text":"Base.eltype(layout::PrimitiveArray)\n\n\n\n\n\nBase.eltype(layout::EmptyArray)\n\n\n\n\n\nBase.eltype(layout::ListType)\n\n\n\n\n\nBase.eltype(layout::IndexedArray)\n\n\n\n\n\nBase.eltype(layout::IndexedOptionArray)\n\n\n\n\n\nBase.eltype(layout::ByteMaskedArray)\n\n\n\n\n\nBase.eltype(layout::BitMaskedArray)\n\n\n\n\n\nBase.eltype(layout::UnmaskedArray)\n\n\n\n\n\nBase.eltype(layout::UnionArray)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.:==","page":"Functions","title":"Base.:==","text":"Base.:(==)(layout1::Content, layout2::Content)\n\nTwo Content objects are considered equal only if they have the same  elements in the same order.\n\n\n\n\n\nBase.:(==)(\n    layout1::RecordArray{FIELDS,CONTENTS1},\n    layout2::RecordArray{FIELDS,CONTENTS2},\n) where {\n    FIELDS,\n    CONTENTS1<:Base.Tuple{Vararg{Content}},\n    CONTENTS2<:Base.Tuple{Vararg{Content}},\n}\n\n\n\n\n\nBase.:(==)(\n    layout1::Record{FIELDS,CONTENTS1},\n    layout2::Record{FIELDS,CONTENTS2},\n) where {\n    FIELDS,\n    CONTENTS1<:Base.Tuple{Vararg{Content}},\n    CONTENTS2<:Base.Tuple{Vararg{Content}},\n}\n\n\n\n\n\nBase.:(==)(\n    layout1::TupleArray{CONTENTS1},\n    layout2::TupleArray{CONTENTS2},\n) where {\n    N,\n    CONTENTS1<:Base.Tuple{Vararg{Content,N}},\n    CONTENTS2<:Base.Tuple{Vararg{Content,N}},\n}\n\n\n\n\n\nBase.:(==)(\n    layout1::SlotRecord{CONTENTS1},\n    layout2::SlotRecord{CONTENTS2},\n) where {\n    N,\n    CONTENTS1<:Base.Tuple{Vararg{Content,N}},\n    CONTENTS2<:Base.Tuple{Vararg{Content,N}},\n}\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.push!","page":"Functions","title":"Base.push!","text":"Base.push!(layout::PrimitiveArray{ITEM}, input::ITEM) where {ITEM}\n\nPush multiple ITEM elements (from another collection) to an instance of PrimitiveArray.\n\n\n\n\n\nBase.push!(layout::PrimitiveArray{ITEM}, input::Number) where {ITEM}\n\n\n\n\n\nBase.push!(layout::EmptyArray, input)\n\n\n\n\n\nBase.push!(layout::ListType{BEHAVIOR}, input::String) where {BEHAVIOR}\n\n\n\n\n\nBase.push!(layout::ListType, input::AbstractVector)\n\n\n\n\n\nBase.push!(\n    layout::RecordArray{FIELDS,CONTENTS},\n    input::NamedTuple{FIELDS},\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\nBase.push!(\n    layout::TupleArray{CONTENTS},\n    input::INPUT,\n) where {N,CONTENTS<:Base.Tuple{Vararg{Content,N}},INPUT<:Base.Tuple{Vararg{Any,N}}}\n\n\n\n\n\nBase.push!(layout::IndexedArray, input)\n\n\n\n\n\nBase.push!(layout::IndexedOptionArray, input)\n\n\n\n\n\nBase.push!(layout::ByteMaskedArray, input)\n\n\n\n\n\nBase.push!(layout::BitMaskedArray, input)\n\n\n\n\n\nBase.push!(layout::UnmaskedArray, input)\n\n\n\n\n\nBase.push!(special::Specialization, input)\n\n\n\n\n\nBase.push!(layout::UnionArray, input)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.append!","page":"Functions","title":"Base.append!","text":"Base.append!(layout::Content, input)\n\nAppend multiple elements (from another collection) to an instance of Content.\n\n\n\n\n\nBase.append!(layout::OptionType, input)\n\nAppending elements to an array of type OptionType, handling missing values.\n\n\n\n\n\nBase.append!(special::Specialization, input)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.show","page":"Functions","title":"Base.show","text":"Base.show(io::IO, parameters::Parameters)\n\n\n\n\n\nBase.show(\n    io::IO,\n    data::Union{Content,Record,Tuple};\n    limit_rows::Int = 1,\n    limit_cols::Int = 80,\n)\n\n\n\n\n\nBase.show(data::Union{Content,Record,Tuple}; limit_rows::Int = 1, limit_cols::Int = 80)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.keys","page":"Functions","title":"Base.keys","text":"Base.keys(parameters::Parameters)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Manipulating-and-checking-structure","page":"Functions","title":"Manipulating and checking structure","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Every Content subclass has the following functions for manipulating and checking structure:","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray.parameters_of gets all parameters\nAwkwardArray.has_parameter returns true if a parameter exists\nAwkwardArray.get_parameter returns a parameter or raises an error\nAwkwardArray.with_parameter returns a copy of this node with a specified parameter\nAwkwardArray.copy shallow-copy of the array, allowing properties to be replaced\nAwkwardArray.is_valid verifies that the structure adheres to Awkward Array's protocol","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"parameters_of\nhas_parameter\nget_parameter\nwith_parameter\ncopy\nis_valid","category":"page"},{"location":"functions/#AwkwardArray.parameters_of","page":"Functions","title":"AwkwardArray.parameters_of","text":"parameters_of(content::CONTENT) where {CONTENT<:Content}\n\nReturn a list of all parameters.\n\n\n\n\n\nparameters_of(content::EmptyArray)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.has_parameter","page":"Functions","title":"AwkwardArray.has_parameter","text":"has_parameter(parameters::Parameters, key::String)\n\n\n\n\n\nhas_parameter(content::CONTENT, key::String) where {CONTENT<:Content}\n\nReturn true if a parameter exists.\n\n\n\n\n\nhas_parameter(content::EmptyArray, key::String)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.get_parameter","page":"Functions","title":"AwkwardArray.get_parameter","text":"get_parameter(parameters::Parameters, key::String)\n\n\n\n\n\nget_parameter(content::CONTENT, key::String) where {CONTENT<:Content}\n\nReturn a parameter or raises an error.\n\n\n\n\n\nget_parameter(content::EmptyArray, key::String)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.with_parameter","page":"Functions","title":"AwkwardArray.with_parameter","text":"with_parameter(parameters::Parameters, pair::Pair{String,String})\n\n\n\n\n\nwith_parameter(parameters::Parameters, pair::Pair{String,<:Any})\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.copy","page":"Functions","title":"AwkwardArray.copy","text":"copy(\n    layout::PrimitiveArray{ITEM,BUFFER1,BEHAVIOR};\n    data::Union{Unset,BUFFER2} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {ITEM,BUFFER1<:AbstractVector{ITEM},BUFFER2<:AbstractVector,BEHAVIOR}\n\n\n\n\n\ncopy(behavior::Union{Unset,Symbol} = Unset())\n\n\n\n\n\ncopy(\n    layout::ListOffsetArray{INDEX1,CONTENT1,BEHAVIOR};\n    offsets::Union{Unset,INDEX2} = Unset(),\n    content::Union{Unset,CONTENT2} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {INDEX1<:IndexBig,INDEX2<:IndexBig,CONTENT1<:Content,CONTENT2<:Content,BEHAVIOR}\n\nCopy of a ListOffsetArray.\n\n\n\n\n\ncopy(\n    layout::ListArray{INDEX1,CONTENT1,BEHAVIOR};\n    starts::Union{Unset,INDEX2} = Unset(),\n    stops::Union{Unset,INDEX2} = Unset(),\n    content::Union{Unset,CONTENT2} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {INDEX1<:IndexBig,INDEX2<:IndexBig,CONTENT1<:Content,CONTENT2<:Content,BEHAVIOR}\n\nCopy of a ListArray.\n\n\n\n\n\ncopy(\n    layout::RegularArray{CONTENT1,BEHAVIOR};\n    content::Union{Unset,CONTENT2} = Unset(),\n    size::Union{Unset,Int} = Unset(),\n    zeros_length::Union{Unset,Int} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {CONTENT1<:Content,CONTENT2<:Content,BEHAVIOR}\n\nCopy of a RegularArray.\n\n\n\n\n\ncopy(\n    layout::RecordArray{FIELDS1,CONTENTS1,BEHAVIOR};\n    contents::Union{Unset,NamedTuple{FIELDS2,CONTENTS2}} = Unset(),\n    length::Union{Unset,Int64} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {\n    FIELDS1,\n    FIELDS2,\n    CONTENTS1<:Base.Tuple{Vararg{Content}},\n    CONTENTS2<:Base.Tuple{Vararg{Content}},\n    BEHAVIOR,\n}\n\n\n\n\n\ncopy(\n    layout::TupleArray{CONTENTS1,BEHAVIOR};\n    contents::Union{Unset,CONTENTS2} = Unset(),\n    length::Union{Unset,Int64} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {\n    CONTENTS1<:Base.Tuple{Vararg{Content}},\n    CONTENTS2<:Base.Tuple{Vararg{Content}},\n    BEHAVIOR,\n}\n\n\n\n\n\ncopy(\n    layout::IndexedArray{INDEX1,CONTENT1,BEHAVIOR};\n    index::Union{Unset,INDEX2} = Unset(),\n    content::Union{Unset,CONTENT2} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {INDEX1<:IndexBig,INDEX2<:IndexBig,CONTENT1<:Content,CONTENT2<:Content,BEHAVIOR}\n\n\n\n\n\ncopy(\n    layout::IndexedOptionArray{INDEX1,CONTENT1,BEHAVIOR};\n    index::Union{Unset,INDEX2} = Unset(),\n    content::Union{Unset,CONTENT2} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {\n    INDEX1<:IndexBigSigned,\n    INDEX2<:IndexBigSigned,\n    CONTENT1<:Content,\n    CONTENT2<:Content,\n    BEHAVIOR,\n}\n\nCopy of an IndexedOptionArray, potentially with some modifications to its fields.\n\n\n\n\n\ncopy(\n    layout::ByteMaskedArray{INDEX1,CONTENT1,BEHAVIOR};\n    mask::Union{Unset,INDEX2} = Unset(),\n    content::Union{Unset,CONTENT2} = Unset(),\n    valid_when::Union{Unset,Bool} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {INDEX1<:IndexBool,INDEX2<:IndexBool,CONTENT1<:Content,CONTENT2<:Content,BEHAVIOR}\n\n\n\n\n\ncopy(\n    layout::BitMaskedArray{CONTENT1,BEHAVIOR};\n    mask::Union{Unset,BitVector} = Unset(),\n    content::Union{Unset,CONTENT2} = Unset(),\n    valid_when::Union{Unset,Bool} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {CONTENT1<:Content,CONTENT2<:Content,BEHAVIOR}\n\n\n\n\n\ncopy(\n    layout::UnmaskedArray{CONTENT1,BEHAVIOR};\n    content::Union{Unset,CONTENT2} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n) where {CONTENT1<:Content,CONTENT2<:Content,BEHAVIOR}\n\n\n\n\n\ncopy(\n    layout::UnionArray{TAGS1,INDEX1,CONTENTS1,BEHAVIOR};\n    tags::Union{Unset,TAGS2} = Unset(),\n    index::Union{Unset,INDEX2} = Unset(),\n    contents::Union{Unset,CONTENTS2} = Unset(),\n    parameters::Union{Unset,Parameters} = Unset(),\n    behavior::Union{Unset,Symbol} = Unset(),\n)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.is_valid","page":"Functions","title":"AwkwardArray.is_valid","text":"is_valid(layout::PrimitiveArray)\n\n\n\n\n\nis_valid(layout::EmptyArray)\n\n\n\n\n\nis_valid(layout::ListOffsetArray)\n\nCheck if a ListOffsetArray is valid.\n\n\n\n\n\nis_valid(layout::ListArray)\n\nCheck if a ListArray is valid.\n\n\n\n\n\nis_valid(layout::RegularArray)\n\nCheck if a RegularArray is valid.\n\n\n\n\n\nis_valid(layout::RecordArray)\n\n\n\n\n\nis_valid(layout::TupleArray)\n\n\n\n\n\nis_valid(layout::IndexedArray)\n\n\n\n\n\nis_valid(layout::IndexedOptionArray)\n\n\n\n\n\nis_valid(layout::ByteMaskedArray)\n\n\n\n\n\nis_valid(layout::BitMaskedArray)\n\n\n\n\n\nis_valid(layout::UnmaskedArray)\n\n\n\n\n\nis_valid(layout::UnionArray)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Filling-an-array","page":"Functions","title":"Filling an array","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Every Content subclass has the following functions for filling an array:","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray.end_list!: closes off a ListType array (ListOffsetArray, ListArray, or RegularArray) in the manner of Python's ak.ArrayBuilder (no begin_list is necessary)\nAwkwardArray.end_record! closes off a RecordArray\nAwkwardArray.end_tuple! closes off a TupleArray\nAwkwardArray.push_null! pushes a missing value onto OptionType arrays (IndexedOptionArray ByteMaskedArray BitMaskedArray or UnmaskedArray)\nAwkwardArray.push_dummy! pushes an unspecified value onto the array (used by ByteMaskedArray and BitMaskedArray which need to have a placeholder in memory behind each missing value)","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"end_list!\nend_record!\nend_tuple!\npush_null!\npush_dummy!","category":"page"},{"location":"functions/#AwkwardArray.end_list!","page":"Functions","title":"AwkwardArray.end_list!","text":"end_list!(layout::ListOffsetArray)\n\n\n\n\n\nend_list!(layout::ListArray)\n\n\n\n\n\nend_list!(layout::RegularArray)\n\n\n\n\n\nend_list!(layout::IndexedArray)\n\n\n\n\n\nend_list!(layout::IndexedOptionArray)\n\n\n\n\n\nend_list!(layout::ByteMaskedArray)\n\n\n\n\n\nend_list!(layout::BitMaskedArray)\n\n\n\n\n\nend_list!(layout::UnmaskedArray)\n\n\n\n\n\nend_list!(special::Specialization)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.end_record!","page":"Functions","title":"AwkwardArray.end_record!","text":"end_record!(layout::RecordArray)\n\n\n\n\n\nend_record!(layout::IndexedArray)\n\n\n\n\n\nend_record!(layout::IndexedOptionArray)\n\n\n\n\n\nend_record!(layout::ByteMaskedArray)\n\n\n\n\n\nend_record!(layout::BitMaskedArray)\n\n\n\n\n\nend_record!(layout::UnmaskedArray)\n\n\n\n\n\nend_record!(special::Specialization)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.end_tuple!","page":"Functions","title":"AwkwardArray.end_tuple!","text":"end_tuple!(layout::TupleArray)\n\n\n\n\n\nend_tuple!(layout::IndexedArray)\n\n\n\n\n\nend_tuple!(layout::IndexedOptionArray)\n\n\n\n\n\nend_tuple!(layout::ByteMaskedArray)\n\n\n\n\n\nend_tuple!(layout::BitMaskedArray)\n\n\n\n\n\nend_tuple!(layout::UnmaskedArray)\n\n\n\n\n\nend_tuple!(special::Specialization)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.push_null!","page":"Functions","title":"AwkwardArray.push_null!","text":"push_null!(layout::IndexedOptionArray)\n\n\n\n\n\npush_null!(layout::ByteMaskedArray)\n\n\n\n\n\npush_null!(layout::BitMaskedArray)\n\n\n\n\n\npush_null!(\n    special::Specialization{ARRAY,TAGGED},\n) where {ARRAY<:UnionArray,TAGGED<:OptionType}\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.push_dummy!","page":"Functions","title":"AwkwardArray.push_dummy!","text":"push_dummy!(layout::PrimitiveArray{ITEM}) where {ITEM}\n\n\n\n\n\npush_dummy!(layout::ListOffsetArray)\n\n\n\n\n\npush_dummy!(layout::ListArray)\n\n\n\n\n\npush_dummy!(layout::RegularArray)\n\n\n\n\n\npush_dummy!(layout::RecordArray)\n\n\n\n\n\npush_dummy!(layout::TupleArray)\n\n\n\n\n\npush_dummy!(layout::IndexedArray)\n\n\n\n\n\npush_dummy!(layout::IndexedOptionArray)\n\n\n\n\n\npush_dummy!(layout::ByteMaskedArray)\n\n\n\n\n\npush_dummy!(layout::BitMaskedArray)\n\n\n\n\n\npush_dummy!(layout::UnmaskedArray)\n\n\n\n\n\npush_dummy!(special::Specialization)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Selecting-fields","page":"Functions","title":"Selecting fields","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"RecordArrayand TupleArray have the following for selecting fields (as opposed to rows):","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray.slot gets a RecordArrayor TupleArray field, to avoid conflicts with Base.getindex for TupleArrays (both use integers to select a field)\nAwkwardArray.Record scalar representation of an item from a RecordArray\nAwkwardArray.SlotRecord scalar representation of an item from a TupleArray(note: not the same as Base.Tuple)","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray.slot","category":"page"},{"location":"functions/#AwkwardArray.slot","page":"Functions","title":"AwkwardArray.slot","text":"slot(\n    layout::RecordArray{FIELDS,CONTENTS,BEHAVIOR},\n    f::Symbol,\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR}\n\n\n\n\n\nslot(\n    layout::TupleArray{CONTENTS,BEHAVIOR},\n    f::Int,\n) where {CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR}\n\n\n\n\n\n","category":"function"},{"location":"functions/#Specializations","page":"Functions","title":"Specializations","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"UnionArrayhas the following for dealing with specializations:","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray.Specialization selects a UnionArrayspecialization for push! append! etc.","category":"page"},{"location":"functions/#Convertion","page":"Functions","title":"Convertion","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Finally, all Contentsubclasses can be converted with the following:","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray.layout_for returns an appropriately-nested Contenttype for a given Julia type (DataType)\nAwkwardArray.from_iter converts Julia data into an Awkward Array\nAwkwardArray.to_vector converts an Awkward Array into Julia data\nAwkwardArray.from_buffers constructs an Awkward Array from a Form (JSON), length, and buffers for zero-copy passing from Python\nAwkwardArray.to_buffers deconstructs an Awkward Array into a Form (JSON), length, and buffers for zero-copy passing to Python","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray.layout_for\nAwkwardArray.from_iter\nAwkwardArray.to_vector\nAwkwardArray.to_vector_or_scalar\nAwkwardArray.from_buffers\nAwkwardArray.to_buffers","category":"page"},{"location":"functions/#AwkwardArray.layout_for","page":"Functions","title":"AwkwardArray.layout_for","text":"layout_for(ItemType)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.from_iter","page":"Functions","title":"AwkwardArray.from_iter","text":"from_iter(input)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.to_vector","page":"Functions","title":"AwkwardArray.to_vector","text":"to_vector(layout::Content; view::Bool = false, na::Union{Missing,Nothing} = missing)\n\n\n\n\n\nto_vector(\n    record::Record{FIELDS,CONTENTS};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}}} = NamedTuple{FIELDS}\n\n\n\n\n\nto_vector(\n    tuple::Tuple{CONTENTS};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\nto_vector(\n    layout::PrimitiveArray{ITEM},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {ITEM}\n\n\n\n\n\nto_vector(\n    layout::EmptyArray,\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n)\n\n\n\n\n\nto_vector(\n    layout::ListOffsetArray{INDEX,CONTENT},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {INDEX<:IndexBig,CONTENT<:Content}\n\n\n\n\n\nto_vector(\n    layout::ListArray{INDEX,CONTENT},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {INDEX<:IndexBig,CONTENT<:Content}\n\n\n\n\n\nto_vector(\n    layout::RegularArray{CONTENT},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {CONTENT<:Content}\n\n\n\n\n\nto_vector(\n    layout::ListOffsetArray{INDEX,PrimitiveArray{UInt8,BUFFER,:char},:string},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {INDEX<:IndexBig,BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nto_vector(\n    layout::ListArray{INDEX,PrimitiveArray{UInt8,BUFFER,:char},:string},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {INDEX<:IndexBig,BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nto_vector(\n    layout::RegularArray{PrimitiveArray{UInt8,BUFFER,:char},:string},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\nto_vector(\n    layout::RecordArray{FIELDS,CONTENTS},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\nto_vector(\n    layout::TupleArray{CONTENTS},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\nto_vector(\n    layout::IndexedArray{INDEX,CONTENT},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {INDEX<:IndexBig,CONTENT<:Content}\n\n\n\n\n\nto_vector(\n    layout::IndexedOptionArray{INDEX,CONTENT},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {INDEX<:IndexBig,CONTENT<:Content}\n\n\n\n\n\nto_vector(\n    layout::ByteMaskedArray{INDEX,CONTENT},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {INDEX<:IndexBool,CONTENT<:Content}\n\n\n\n\n\nto_vector(\n    layout::BitMaskedArray{CONTENT},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {CONTENT<:Content}\n\n\n\n\n\nto_vector(\n    layout::UnmaskedArray{CONTENT},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {CONTENT<:Content}\n\n\n\n\n\nto_vector(\n    layout::UnionArray{TAGS,INDEX,CONTENTS},\n    r::UnitRange{Int};\n    view::Bool = false,\n    na::Union{Missing,Nothing} = missing,\n) where {TAGS<:Index8,INDEX<:IndexBig,CONTENTS<:Base.Tuple}\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.to_vector_or_scalar","page":"Functions","title":"AwkwardArray.to_vector_or_scalar","text":"to_vector_or_scalar(x::Content; view::Bool = false, na::Union{Missing,Nothing} = missing)\n\n\n\n\n\nto_vector_or_scalar(x; view::Bool = false, na = missing)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.from_buffers","page":"Functions","title":"AwkwardArray.from_buffers","text":"from_buffers(\n    form::String,\n    length::Int,\n    containers::Dict{String,BUFFER};\n    buffer_key::BUFFER_KEY_FUNCTION = default_buffer_key,\n) where {BUFFER<:AbstractVector{UInt8},BUFFER_KEY_FUNCTION<:Function}\n\n\n\n\n\nfrom_buffers(\n    form::Dict{String,Any},\n    length::Int,\n    containers::Dict{String,BUFFER};\n    buffer_key::BUFFER_KEY_FUNCTION = default_buffer_key,\n) where {BUFFER<:AbstractVector{UInt8},BUFFER_KEY_FUNCTION<:Function}\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.to_buffers","page":"Functions","title":"AwkwardArray.to_buffers","text":"to_buffers(layout::Content)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Arrays-of-Stings","page":"Functions","title":"Arrays of Stings","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"ByteStringOffsetArray\nByteStringArray\nByteStringRegularArray\nStringArray\nStringOffsetArray\nStringRegularArray","category":"page"},{"location":"functions/#AwkwardArray.ByteStringOffsetArray","page":"Functions","title":"AwkwardArray.ByteStringOffsetArray","text":"ByteStringOffsetArray(\n    offsets::INDEX,\n    data::AbstractVector{UInt8};\n    parameters::Parameters = Parameters(),\n    byte_parameters::Parameters = Parameters(),\n) where {INDEX<:IndexBig}\n\nThe function that constructs a specialized array type for handling byte strings with specific offsets.\n\noffsets: This is an array of indices (INDEX) which determines where each string starts within the byte array.\ndata: This is a vector of UInt8 (unsigned 8-bit integers), representing the raw bytes of the strings.\nparameters: Optional parameters for configuring the ListOffsetArray.\nbyte_parameters: Optional parameters specifically for the PrimitiveArray holding the byte data.\nINDEX<: Ensures that offsets is a subtype of IndexBig, which typically implies a larger indexing type suitable for big data.\n\nnote: Note\nIt is a ListType with behavior = :bytestring.\n\n\n\n\n\nByteStringOffsetArray(;\n    parameters::Parameters = Parameters(),\n    byte_parameters::Parameters = Parameters(),\n)\n\nA default constructor that initializes an empty ByteStringOffsetArray.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.ByteStringArray","page":"Functions","title":"AwkwardArray.ByteStringArray","text":"ByteStringArray(\n    starts::INDEX,\n    stops::INDEX,\n    data::AbstractVector{UInt8};\n    parameters::Parameters = Parameters(),\n    byte_parameters::Parameters = Parameters(),\n) where {INDEX<:IndexBig}\n\nThe ByteStringArray function constructs a specialized array type for handling byte strings, similar to ByteStringOffsetArray, but it uses separate starts and stops indices rather than a single offsets array.\n\n\n\n\n\nByteStringArray(;\n    parameters::Parameters = Parameters(),\n    byte_parameters::Parameters = Parameters(),\n)\n\nA default constructor that initializes an empty ByteStringArray.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.ByteStringRegularArray","page":"Functions","title":"AwkwardArray.ByteStringRegularArray","text":"ByteStringRegularArray(\n    data::AbstractVector{UInt8},\n    size::Int;\n    zeros_length::Int = 0,\n    parameters::Parameters = Parameters(),\n    byte_parameters::Parameters = Parameters(),\n)\n\n\n\n\n\nByteStringRegularArray(\n    size::Int;\n    parameters::Parameters = Parameters(),\n    byte_parameters::Parameters = Parameters(),\n)\n\n\n\n\n\nByteStringRegularArray(;\n    parameters::Parameters = Parameters(),\n    byte_parameters::Parameters = Parameters(),\n)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.StringArray","page":"Functions","title":"AwkwardArray.StringArray","text":"StringArray(\n    starts::INDEX,\n    stops::INDEX,\n    data::AbstractVector{UInt8};\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n) where {INDEX<:IndexBig}\n\n\n\n\n\nStringArray(\n    starts::INDEX,\n    stops::INDEX,\n    data::String;   # data provided as a String, rather than AbstractVector{UInt8}\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n) where {INDEX<:IndexBig}\n\n\n\n\n\nStringArray(;\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.StringOffsetArray","page":"Functions","title":"AwkwardArray.StringOffsetArray","text":"StringOffsetArray(\n    offsets::INDEX,\n    data::AbstractVector{UInt8};\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n) where {INDEX<:IndexBig}\n\n\n\n\n\nStringOffsetArray(\n    offsets::INDEX,\n    data::String;\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n) where {INDEX<:IndexBig}\n\n\n\n\n\nStringOffsetArray(; parameters = Parameters(), char_parameters = Parameters())\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.StringRegularArray","page":"Functions","title":"AwkwardArray.StringRegularArray","text":"StringRegularArray(\n    data::AbstractVector{UInt8},\n    size::Int;\n    zeros_length::Int = 0,\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n)\n\n\n\n\n\nStringRegularArray(\n    data::String,\n    size::Int;\n    zeros_length::Int = 0,\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n)\n\n\n\n\n\nStringRegularArray(\n    size::Int;\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n)\n\n\n\n\n\nStringRegularArray(;\n    parameters::Parameters = Parameters(),\n    char_parameters::Parameters = Parameters(),\n)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Utilities","page":"Functions","title":"Utilities","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray.isprimitive\nAwkwardArray.default_buffer_key\nAwkwardArray.compatible\nAwkwardArray.check_primitive_type","category":"page"},{"location":"functions/#AwkwardArray.isprimitive","page":"Functions","title":"AwkwardArray.isprimitive","text":"isprimitive(t::Type)\n\nDetermine if a given type is one of the fundamental data types in Julia  that are typically considered primitive. These include:\n\nInteger: Represents all integer types (e.g., Int64, UInt8). AbstractFloat: Represents all floating-point types (e.g., Float64, Float32). Bool: Represents boolean values (true and false). Char: Represents character values.\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.default_buffer_key","page":"Functions","title":"AwkwardArray.default_buffer_key","text":"default_buffer_key(form_key::String, attribute::String)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.compatible","page":"Functions","title":"AwkwardArray.compatible","text":"compatible(parameters1::Parameters, parameters2::Parameters)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray.check_primitive_type","page":"Functions","title":"AwkwardArray.check_primitive_type","text":"check_primitive_type(ITEM)\n\nA utility that provides a string representation for various primitive  types in Julia. It helps in identifying the type of an item and mapping  it to a human-readable format. This is useful in scenarios where type  information needs to be logged, serialized, or displayed. If a type is  not recognized, it defaults to returning unknown.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Private-functions","page":"Functions","title":"Private functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"AwkwardArray._alternate\nAwkwardArray._get_buffer\nAwkwardArray._get_index\nAwkwardArray._horizontal\nAwkwardArray._to_buffers!\nAwkwardArray._to_buffers_index\nAwkwardArray._to_buffers_parameters\nAwkwardArray._vertical","category":"page"},{"location":"functions/#AwkwardArray._alternate","page":"Functions","title":"AwkwardArray._alternate","text":"_alternate(range::AbstractRange{Int64})\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray._get_buffer","page":"Functions","title":"AwkwardArray._get_buffer","text":"_get_buffer(\n    form_key::Union{Nothing,String},\n    attribute::String,\n    buffer_key::BUFFER_KEY_FUNCTION,\n    containers::Dict{String,BUFFER},\n) where {BUFFER<:AbstractVector{UInt8},BUFFER_KEY_FUNCTION<:Function}\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray._get_index","page":"Functions","title":"AwkwardArray._get_index","text":"_get_index(\n    form_snippet::String,\n    length::Int64,\n    buffer::BUFFER,\n) where {BUFFER<:AbstractVector{UInt8}}\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray._horizontal","page":"Functions","title":"AwkwardArray._horizontal","text":"_horizontal(data::Any, limit_cols::Int)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray._to_buffers!","page":"Functions","title":"AwkwardArray._to_buffers!","text":"_to_buffers!(\n    layout::PrimitiveArray{ITEM,BUFFER},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {ITEM,BUFFER<:AbstractVector{ITEM}}\n\n\n\n\n\n_to_buffers!(\n    layout::EmptyArray,\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n)\n\n\n\n\n\n_to_buffers!(\n    layout::ListOffsetArray{INDEX,CONTENT},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {INDEX<:IndexBig,CONTENT<:Content}\n\n\n\n\n\n_to_buffers!(\n    layout::ListArray{INDEX,CONTENT},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {INDEX<:IndexBig,CONTENT<:Content}\n\n\n\n\n\n_to_buffers!(\n    layout::RegularArray{CONTENT},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {CONTENT<:Content}\n\n\n\n\n\n_to_buffers!(\n    layout::RecordArray{FIELDS,CONTENTS},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\n_to_buffers!(\n    layout::TupleArray{CONTENTS},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\n_to_buffers!(\n    layout::IndexedArray{INDEX,CONTENT},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {INDEX<:IndexBig,CONTENT<:Content}\n\n\n\n\n\n_to_buffers!(\n    layout::IndexedOptionArray{INDEX,CONTENT},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {INDEX<:IndexBigSigned,CONTENT<:Content}\n\n\n\n\n\n_to_buffers!(\n    layout::ByteMaskedArray{INDEX,CONTENT},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {INDEX<:IndexBool,CONTENT<:Content}\n\n\n\n\n\n_to_buffers!(\n    layout::BitMaskedArray{CONTENT},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {CONTENT<:Content}\n\n\n\n\n\n_to_buffers!(\n    layout::UnmaskedArray{CONTENT},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {CONTENT<:Content}\n\n\n\n\n\n_to_buffers!(\n    layout::UnionArray{TAGS,INDEX,CONTENTS},\n    number::Vector{Int64},\n    containers::Dict{String,AbstractVector{UInt8}},\n) where {TAGS<:Index8,INDEX<:IndexBig,CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray._to_buffers_index","page":"Functions","title":"AwkwardArray._to_buffers_index","text":"_to_buffers_index(IndexType::DataType)\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray._to_buffers_parameters","page":"Functions","title":"AwkwardArray._to_buffers_parameters","text":"_to_buffers_parameters(layout::CONTENT) where {BEHAVIOR,CONTENT<:Content{BEHAVIOR}}\n\n\n\n\n\n","category":"function"},{"location":"functions/#AwkwardArray._vertical","page":"Functions","title":"AwkwardArray._vertical","text":"_vertical(data::Union{Content,Record,Tuple}, limit_rows::Int, limit_cols::Int)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"api/#Public-Documentation","page":"Reference Guide","title":"Public Documentation","text":"","category":"section"},{"location":"api/","page":"Reference Guide","title":"Reference Guide","text":"Documentation for AwkwardArray.jl's public interface.","category":"page"},{"location":"api/","page":"Reference Guide","title":"Reference Guide","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"api/#Index","page":"Reference Guide","title":"Index","text":"","category":"section"},{"location":"api/","page":"Reference Guide","title":"Reference Guide","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Public-Interface","page":"Reference Guide","title":"Public Interface","text":"","category":"section"},{"location":"howto/#How-to-build-documentation-locally","page":"HowTo","title":"How to build documentation locally","text":"","category":"section"},{"location":"howto/","page":"HowTo","title":"HowTo","text":"julia --project=docs/  docs/make.jl","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Let's assume that both Python and Julia are installed.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"note: Note\nIf Julia is not install it is recomended to follow its official installation instructions described here.","category":"page"},{"location":"getting_started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"It is recommended to use conda virtul environment.","category":"page"},{"location":"getting_started/#Using-Julia-Awkward-Arrays-from-Python","page":"Getting started","title":"Using Julia Awkward Arrays from Python","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To install Awkward Array Python package:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"conda install -c conda-forge awkward","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To install JuliaCall:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"conda install pyjuliacall","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"JuliaCall takes care of installing all necessary Julia packages, including this package. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"import awkward as ak\nfrom juliacall import Main as jl\n\njl.seval(\"using AwkwardArray\")","category":"page"},{"location":"getting_started/#Using-Python-Awkward-Arrays-from-Julia","page":"Getting started","title":"Using Python Awkward Arrays from Julia","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"PythonCall is currently configured to use the Julia-specific Python distribution installed by the CondaPkg.jl package.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using CondaPkg\nCondaPkg.add(\"awkward\")","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using PythonCall\n\nconst ak = pyimport(\"awkward\")\n\nprintln(ak.__version__)\n2.6.4","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"See Examples.","category":"page"},{"location":"exampleusage/#Converting-to-and-from-Julia-objects","page":"Converting Arrays","title":"Converting to and from Julia objects","text":"","category":"section"},{"location":"exampleusage/","page":"Converting Arrays","title":"Converting Arrays","text":"using AwkwardArray\n\nAwkwardArray.to_vector(array)\n4-element Vector{Vector{Float64}}:\n [1.1, 2.2, 3.3]\n [4.4]\n [5.5, 6.6]\n [7.7, 8.8, 9.9]\n\nAwkwardArray.from_iter(AwkwardArray.to_vector(array))\n4-element ListOffsetArray{Vector{Int64}, PrimitiveArray{Float64, Vector{Float64}, :default}, :default}:\n [1.1, 2.2, 3.3]\n [4.4]\n [5.5, 6.6]\n [7.7, 8.8, 9.9]","category":"page"},{"location":"exampleusage/#Converting-from-Python-to-Julia","page":"Converting Arrays","title":"Converting from Python to Julia","text":"","category":"section"},{"location":"exampleusage/","page":"Converting Arrays","title":"Converting Arrays","text":"PythonCall is currently configured to use the Julia-specific Python distribution installed by the CondaPkg.jl package.","category":"page"},{"location":"exampleusage/","page":"Converting Arrays","title":"Converting Arrays","text":"using CondaPkg\nCondaPkg.add(\"awkward\")","category":"page"},{"location":"exampleusage/","page":"Converting Arrays","title":"Converting Arrays","text":"using PythonCall\n\nconst ak = pyimport(\"awkward\")\n\nprintln(ak.__version__)\n2.5.0","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"MIT License","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"Copyright (c) 2023 Jim Pivarski <pivarski@princeton.edu>, Jerry Ling <jerry.ling@cern.ch>, and contributors","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"CurrentModule = AwkwardArray","category":"page"},{"location":"indexing/#Types","page":"Indexing","title":"Types","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"Pages = [\"indexing.md\"]","category":"page"},{"location":"indexing/#Indexing","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"indexing/","page":"Indexing","title":"Indexing","text":"FIXME","category":"page"},{"location":"#Why?","page":"Introduction","title":"Why?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Awkward Array is a library for manipulating large-scale arrays of nested, variable-sized data in Python, using array-oriented idioms: like NumPy, but for any JSON-like data. In Python, using array-oriented idioms to avoid imperative for loops is necessary for fast computations. In Julia, imperative code is already fast, thanks to JIT-compilation, so you may be wondering why this package exists.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is a complete, one-to-one implementation of the Awkward Array data structures in Julia, which makes it possible to zero-copy share data between the two languages. Python scripts can sneak out to Julia to run a calculation at high speed. Julia programs can duck into Python to access some code that has been written in that language. PythonCall & JuliaCall provide these capabilities (which this package uses) for ordinary data types; this package allows arrays of complex data to be shared as well.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Beyond communication with Python, columnar memory layouts have some advantages: data in an Awkward Array is less fragmented than the equivalent Vectors of Vectors, NamedTuples, Missing, and Union data of the built-in Julia types. Other, well-established packages provide some of these capabilities: ArraysOfArrays.jl does Vectors of variable-length Vectors, and StructArrays.jl toggles between array-of-structs/struct-of-arrays like Awkward records do, but Awkward Arrays represent a closure over a large suite of data types:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"booleans/numbers/dates/times\nvariable-length and regular-sized lists\nstructs with named (record) and unnamed (tuple) fields\nmissing data in a variety of representations (bit vectors, byte vectors, union-indexes)\nheterogeneous unions","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"with the ability to add metadata and overload behavior at every level. (For instance, an array of strings is an array of lists of bytes with overloaded methods, taking advantage of Julia's multiple dispatch.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Additionally, arrow-julia provides Julia access to the Apache Arrow format, which is also good for in-memory interprocess communication, but the Awkward Array format is a superset of this format to make it easier to represent intermediate calculations.","category":"page"},{"location":"#Reading-and-writing-the-same-data-type","page":"Introduction","title":"Reading and writing the same data type","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"AwkwardArray.jl is a reimplementation of the concept of Awkward Arrays in Julia, taking advantage of Julia's capabilities. Python's Awkward Array has other backends for sending data to JIT-compiled languagesNumba (CPU and GPU) and C++ (with cppyy and ROOT's RDataFrame)but as read-only views, owned exclusively by Python, for brief excursions only. Creating new Awkward Arrays in those JIT-compiled languages requires special tools, ak.ArrayBuilder (discovers data type during iteration) and LayoutBuilder (fills a specified data type; faster).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In Julia, the array/builder dichotomy can be eliminated. Every Awkward Array is also a LayoutBuilder: they are appendable with the built-in push! and append! functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using AwkwardArray: Index64, ListOffsetArray, PrimitiveArray\n\njulia> array = ListOffsetArray{Index64,PrimitiveArray{Float64}}()\n0-element ListOffsetArray{Vector{Int64}, PrimitiveArray{Float64, Vector{Float64}, :default}, :default}\n\njulia> push!(array, [1.1, 2.2, 3.3])\n1-element ListOffsetArray{Vector{Int64}, PrimitiveArray{Float64, Vector{Float64}, :default}, :default}:\n [1.1, 2.2, 3.3]\n\njulia> push!(array, [4.4])\n2-element ListOffsetArray{Vector{Int64}, PrimitiveArray{Float64, Vector{Float64}, :default}, :default}:\n [1.1, 2.2, 3.3]\n [4.4]\n\njulia> append!(array, [[5.5, 6.6], [7.7, 8.8, 9.9]])\n4-element ListOffsetArray{Vector{Int64}, PrimitiveArray{Float64, Vector{Float64}, :default}, :default}:\n [1.1, 2.2, 3.3]\n [4.4]\n [5.5, 6.6]\n [7.7, 8.8, 9.9]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the same type of array that can be iterated over","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> total = 0.0\n0.0\n\njulia> for list in array\n           for item in list\n               total += item\n           end\n       end\n\njulia> total\n49.5","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"converted to and from Julia objects","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using AwkwardArray\n\njulia> AwkwardArray.to_vector(array)\n4-element Vector{Vector{Float64}}:\n [1.1, 2.2, 3.3]\n [4.4]\n [5.5, 6.6]\n [7.7, 8.8, 9.9]\n\njulia> AwkwardArray.from_iter(AwkwardArray.to_vector(array))\n4-element ListOffsetArray{Vector{Int64}, PrimitiveArray{Float64, Vector{Float64}, :default}, :default}:\n [1.1, 2.2, 3.3]\n [4.4]\n [5.5, 6.6]\n [7.7, 8.8, 9.9]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"and passed to and from Python. Thus, AwkwardArray.jl is the only JIT-compiled Awkward Array backend that can own its own data.","category":"page"},{"location":"#Composability","page":"Introduction","title":"Composability","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"AwkwardArray.jl accepts any AbstractVector for index and data buffers, so that buffers on GPUs, data with units, etc. can be used in place of the usual Vector type.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"None of AwkwardArray.jl's algorithms assume that these buffers are 1-indexed, so even OffsetArrays.jl could be used as buffers. This is also important because the data in the index buffers are 0-indexed, so that they can be zero-copy exchanged with Python.","category":"page"},{"location":"#[Array-layout-classes](@ref)-and-behavior","page":"Introduction","title":"Array layout classes and behavior","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Any node in the data-type tree can carry Dict{String,Any} metadata as parameters, as well as a behavior::Symbol that can be used to define specialized behaviors. For instance, arrays of strings (constructed with StringOffsetArray, StringArray, or StringRegularArray) are defined by behavior = :string (instead of behavior = :default).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using AwkwardArray: StringOffsetArray\n\njulia> array = StringOffsetArray()\n0-element ListOffsetArray{Vector{Int64}, PrimitiveArray{UInt8, Vector{UInt8}, :char}, :string}\n\njulia> append!(array, [\"one\", \"two\", \"three\", \"four\", \"five\"])\n5-element ListOffsetArray{Vector{Int64}, PrimitiveArray{UInt8, Vector{UInt8}, :char}, :string}:\n \"one\"\n \"two\"\n \"three\"\n \"four\"\n \"five\"\n\njulia> array[3]\n\"three\"\n\njulia> typeof(array[3])\nString","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Most applications of behavior apply to RecordArrays (e.g. Vector in Python).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = AwkwardArray","category":"page"},{"location":"internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"FIXME","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"CurrentModule = AwkwardArray","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Array-layout-classes","page":"Types","title":"Array layout classes","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"In Python, we make a distinction between high-level ak.Array (for data analysts) and low-level Content memory layouts (for downstream developers). In Julia, it's more advantageous to expose the concrete type details to all users, particularly for defining functions with multiple dispatch. Thus, there is no ak.Array equivalent.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The layout classes (subclasses of AwkwardArray.Content) are:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Julia class corresponding Python corresponding Arrow description\nPrimitiveArray NumpyArray primitive one-dimensional array of booleans, numbers, date-times, or time-differences\nEmptyArray EmptyArray (none) length-zero array with unknown type (usually derived from untyped sources)\nListOffsetArray ListOffsetArray list variable-length lists defined by an index of offsets\nListArray ListArray (none) variable-length lists defined by more general starts and stops indexes\nRegularArray RegularArray fixed-size lists of uniform size\nRecordArray RecordArray with fields struct struct-like records with named fields of different types\nTupleArray RecordArray with fields=None (none) tuples of unnamed fields of different types\nIndexedArray IndexedArray dictionary data that are lazily filtered, duplicated, and/or rearranged by an integer index\nIndexedOptionArray IndexedOptionArray (none) same but negative values in the index correspond to Missing values\nByteMaskedArray ByteMaskedArray (none) possibly-missing data, defined by a byte mask\nBitMaskedArray (only lsb_order = true) BitMaskedArray bitmaps same, defined by a BitVector\nUnmaskedArray UnmaskedArray same in-principle missing data, but none are actually missing so no mask\nUnionArray UnionArray dense union data of different types in the same array","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Any node in the data-type tree can carry Dict{String,Any} metadata as parameters, as well as a behavior::Symbol that can be used to define specialized behaviors. For instance, arrays of strings (constructed with StringOffsetArray, StringArray, or StringRegularArray) are defined by behavior = :string (instead of behavior = :default).","category":"page"},{"location":"types/#Types-specification","page":"Types","title":"Types specification","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [AwkwardArray]\nPublic = true\nOrder = [:type]","category":"page"},{"location":"types/#AwkwardArray.BitMaskedArray","page":"Types","title":"AwkwardArray.BitMaskedArray","text":"BitMaskedArray{CONTENT<:Content,BEHAVIOR} <: OptionType{BEHAVIOR}\n\nSpecialized array type designed to handle masked arrays, where certain elements can be marked as valid or invalid using a BitVector. \n\nInherits from OptionType.\n\nstruct BitMaskedArray{CONTENT<:Content,BEHAVIOR} <: OptionType{BEHAVIOR}\n    mask::BitVector\n    content::CONTENT\n    valid_when::Bool\n    parameters::Parameters\n\n    BitMaskedArray(\n        mask::BitVector,\n        content::CONTENT;\n        valid_when::Bool = false,\n        parameters::Parameters = Parameters(),\n        behavior::Symbol = :default,\n    ) where {CONTENT<:Content} =\n        new{CONTENT,behavior}(mask, content, valid_when, parameters)\nend\n\nType Parameters:\n\nCONTENT<:Content: The CONTENT type parameter is constrained to be a subtype of Content.\nBEHAVIOR: A type parameter that can represent different behaviors associated with the array.\n\nInheritance:\n\n<: OptionType{BEHAVIOR}: Indicates that BitMaskedArray is a subtype of OptionType parameterized by BEHAVIOR.\n\nFields:\n\nmask::BitVector: A BitVector indicating which elements are valid or invalid.\ncontent::CONTENT: The actual data content, constrained to be a subtype of Content.\nvalid_when::Bool: A flag indicating when the mask is valid (by default false).\n\nnote: Note\nNumPy MaskedArray's convention; note that Arrow's is true.\n\nparameters::Parameters: Additional parameters associated with the array, defined elsewhere.\n\nConstructor:\n\nBitMaskedArray(\n    mask::BitVector, \n    content::CONTENT; \n    valid_when::Bool = false, \n    parameters::Parameters = Parameters(), \n    behavior::Symbol = :default\n) where {CONTENT<:Content}\n\nThis is the outer constructor for the BitMaskedArray struct. It initializes a new instance of BitMaskedArray with the given mask, content, and optional valid_when, parameters, and behavior. The where {CONTENT<:Content} clause ensures that CONTENT satisfies the specified constraint.\n\nnew{CONTENT,behavior}(mask, content, valid_when, parameters)\n\ncreates a new instance of BitMaskedArray with the specified type parameters and field values.\n\nnote: Note\nAll Python BitMaskedArrays must be converted to lsb_order = true.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.BitMaskedArray-Union{Tuple{}, Tuple{CONTENT}} where CONTENT<:AwkwardArray.Content","page":"Types","title":"AwkwardArray.BitMaskedArray","text":"BitMaskedArray{CONTENT}(;\n    valid_when::Bool = false,\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {CONTENT<:Content}\n\nOuter constructor to create an instance of BitMaskedArray with default or specified values for valid_when, parameters, and behavior, while initializing the mask and content with default empty instances.\n\nBitMaskedArray{CONTENT}(;\n    valid_when::Bool = false,\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {CONTENT<:Content} = BitMaskedArray(\n    BitVector(),\n    CONTENT(),\n    valid_when = valid_when,\n    parameters = parameters,\n    behavior = behavior,\n)\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.ByteMaskedArray","page":"Types","title":"AwkwardArray.ByteMaskedArray","text":"ByteMaskedArray{INDEX<:IndexBool, CONTENT<:Content, BEHAVIOR} <: OptionType{BEHAVIOR}\n\nSpecialized array type designed to handle arrays where elements can be optionally masked using a mask of type INDEX (which is constrained to be a subtype of IndexBool).\n\nInherits from OptionType.\n\nstruct ByteMaskedArray{INDEX<:IndexBool, CONTENT<:Content, BEHAVIOR} <: OptionType{BEHAVIOR}\n    mask::INDEX\n    content::CONTENT\n    valid_when::Bool\n    parameters::Parameters\n\n    ByteMaskedArray(\n        mask::INDEX,\n        content::CONTENT;\n        valid_when::Bool = false,  # the NumPy MaskedArray convention\n        parameters::Parameters = Parameters(),\n        behavior::Symbol = :default,\n    ) where {INDEX<:IndexBool, CONTENT<:Content} =\n        new{INDEX, CONTENT, behavior}(mask, content, valid_when, parameters)\nend\n\nType Parameters:\n\nINDEX<:IndexBool: The INDEX type parameter is constrained to be a subtype of IndexBool, indicating that the mask is of a specific boolean index type.\nCONTENT<:Content: The CONTENT type parameter is constrained to be a subtype of Content.\nBEHAVIOR: A type parameter that can represent different behaviors associated with the array.\n\nInheritance:\n\n<: OptionType{BEHAVIOR}: Indicates that ByteMaskedArray is a subtype of OptionType parameterized by BEHAVIOR.\n\nFields:\n\nmask::INDEX: The mask used to indicate valid or invalid elements, constrained to be a subtype of IndexBool.\ncontent::CONTENT: The actual data content, constrained to be a subtype of Content.\nvalid_when::Bool: A flag indicating when the mask is valid (by default false).\nparameters::Parameters: Additional parameters associated with the array, defined elsewhere.\n\nConstructor:\n\nByteMaskedArray(\n    mask::INDEX, \n    content::CONTENT; \n    valid_when::Bool = false, \n    parameters::Parameters = Parameters(), \n    behavior::Symbol = :default\n) where {INDEX<:IndexBool, CONTENT<:Content}:\n\nThis is the outer constructor for the ByteMaskedArray struct. It initializes a new instance of ByteMaskedArray with the given mask, content, and optional valid_when, parameters, and behavior. The where {INDEX<:IndexBool, CONTENT<:Content} clause ensures that INDEX and CONTENT satisfy the specified constraints.\n\nnew{INDEX, CONTENT, behavior}(mask, content, valid_when, parameters)\n\ncreates a new instance of ByteMaskedArray with the specified type parameters and field values.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.ByteMaskedArray-Union{Tuple{}, Tuple{INDEX}, Tuple{CONTENT}} where {CONTENT<:AwkwardArray.Content, INDEX<:Union{AbstractVector{Bool}, AbstractVector{Int8}}}","page":"Types","title":"AwkwardArray.ByteMaskedArray","text":"ByteMaskedArray{INDEX,CONTENT}(;\n    valid_when::Bool = false,\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {INDEX<:IndexBool} where {CONTENT<:Content}\n\nConvenience constructor for the ByteMaskedArray struct. This constructor allows you to create a ByteMaskedArray instance with default values for its fields, particularly for the mask and content, by specifying only the optional parameters.\n\nByteMaskedArray{INDEX,CONTENT}(;\n    valid_when::Bool = false,\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {INDEX<:IndexBool} where {CONTENT<:Content} = ByteMaskedArray(\n    INDEX([]),\n    CONTENT(),\n    valid_when = valid_when,\n    parameters = parameters,\n    behavior = behavior,\n)\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.Content","page":"Types","title":"AwkwardArray.Content","text":"Abstract Content type. Each layout is subtype from this.\n\nList of functions\n\nEvery Content subclass has the following built-in functions:\n\nBase.length\nBase.size (1-tuple of length)\nBase.firstindex, Base.lastindex (1-based or inherited from its index)\nBase.getindex: select by Int (single item), UnitRange{Int} (slice), and Symbol (record field)\nBase.iterate\nBase.:(==) (equality defined by values: a ListOffsetArray and a ListArray may be considered the same)\nBase.push!\nBase.append!\nBase.show\n\nThey also have the following functions for manipulating and checking structure:\n\nAwkwardArray.parameters_of: gets all parameters\nAwkwardArray.has_parameter: returns true if a parameter exists\nAwkwardArray.get_parameter: returns a parameter or raises an error\nAwkwardArray.with_parameter: returns a copy of this node with a specified parameter\nAwkwardArray.copy: shallow-copy of the array, allowing properties to be replaced\nAwkwardArray.is_valid: verifies that the structure adheres to Awkward Array's protocol\n\nThey have the following functions for filling an array:\n\nAwkwardArray.end_list!: closes off a ListType array (ListOffsetArray, ListArray, or RegularArray) in the manner of Python's ak.ArrayBuilder (no begin_list is necessary)\nAwkwardArray.end_record!: closes off a RecordArray\nAwkwardArray.end_tuple!: closes off a TupleArray\nAwkwardArray.push_null!: pushes a missing value onto OptionType arrays (IndexedOptionArray, ByteMaskedArray, BitMaskedArray, or UnmaskedArray)\nAwkwardArray.push_dummy!: pushes an unspecified value onto the array (used by ByteMaskedArray and BitMaskedArray, which need to have a placeholder in memory behind each missing value)\n\nRecordArray and TupleArray have the following for selecting fields (as opposed to rows):\n\nAwkwardArray.slot: gets a RecordArray or TupleArray field, to avoid conflicts with Base.getindex for TupleArrays (both use integers to select a field)\nAwkwardArray.Record: scalar representation of an item from a RecordArray\nAwkwardArray.SlotRecord: scalar representation of an item from a TupleArray (note: not the same as Base.Tuple)\n\nUnionArray has the following for dealing with specializations:\n\nAwkwardArray.Specialization: selects a UnionArray specialization for push!, append!, etc.\n\nFinally, all Content subclasses can be converted with the following:\n\nAwkwardArray.layout_for: returns an appropriately-nested Content type for a given Julia type (DataType)\nAwkwardArray.from_iter: converts Julia data into an Awkward Array\nAwkwardArray.to_vector: converts an Awkward Array into Julia data\nAwkwardArray.from_buffers: constructs an Awkward Array from a Form (JSON), length, and buffers for zero-copy passing from Python\nAwkwardArray.to_buffers: deconstructs an Awkward Array into a Form (JSON), length, and buffers for zero-copy passing to Python\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.EmptyArray","page":"Types","title":"AwkwardArray.EmptyArray","text":"Represents an array that is always empty.\n\nstruct EmptyArray{BEHAVIOR} <: LeafType{BEHAVIOR}\n    behavior::Symbol\n    \n    function EmptyArray(; behavior::Symbol = :default)\n        new{behavior}(behavior)\n    end\nend\n\nType Parameter:\n\n{BEHAVIOR}: The EmptyArray type has a parameter BEHAVIOR which is used to parameterize the type. This can be useful for specifying different behaviors or properties for different instances of EmptyArray.\n\nInheritance:\n\n<: LeafType{BEHAVIOR}: This indicates that EmptyArray is a subtype of LeafType with the same BEHAVIOR parameter.\n\nField:\n\nbehavior::Symbol: This field stores a Symbol indicating the behavior of the empty array. A Symbol in Julia is a type that represents interned strings and is often used for identifiers and labels.\n\nConstructor:\n\nfunction EmptyArray(; behavior::Symbol = :default): This is an inner constructor that allows for the creation of EmptyArray instances. The behavior argument is optional and defaults to :default if not provided. new{behavior}(behavior): The new function is used to create an instance of EmptyArray with the specified behavior. The {behavior} syntax is used to pass the type parameter to the instance.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.IndexedArray","page":"Types","title":"AwkwardArray.IndexedArray","text":"IndexedArray{INDEX<:IndexBig,CONTENT<:Content,BEHAVIOR} <: Content{BEHAVIOR}\n\nIndexedArray represents an array that references its elements through an index.\n\nstruct IndexedArray{INDEX<:IndexBig, CONTENT<:Content, BEHAVIOR} <: Content{BEHAVIOR}\n    index::INDEX\n    content::CONTENT\n    parameters::Parameters\n\n    IndexedArray(\n        index::INDEX,\n        content::CONTENT;\n        parameters::Parameters = Parameters(),\n        behavior::Symbol = :default,\n    ) where {INDEX<:IndexBig, CONTENT<:Content} =\n        new{INDEX, CONTENT, behavior}(index, content, parameters)\nend\n\nType Parameters:\n\n{INDEX<:IndexBig, CONTENT<:Content, BEHAVIOR}: These are the type parameters for the struct.\nINDEX<:IndexBig: INDEX must be a subtype of IndexBig.\nCONTENT<:Content: CONTENT must be a subtype of Content.\nBEHAVIOR: A type parameter for specifying behavior, often used for distinguishing different kinds of behaviors or properties in the array.\n\nInheritance:\n\n<: Content{BEHAVIOR}: This indicates that IndexedArray is a subtype of Content with the specified BEHAVIOR parameter.\n\nFields:\n\nindex::INDEX: An index of type INDEX, which is a subtype of IndexBig.\ncontent::CONTENT: The actual content of the array, of type CONTENT, which is a subtype of Content.\nparameters::Parameters: An instance of Parameters that holds additional metadata or configuration for the array.\n\nConstructor:\n\nIndexedArray(index::INDEX, content::CONTENT; parameters::Parameters = Parameters(), behavior::Symbol = :default)\n\nThis is an inner constructor that allows for the creation of IndexedArray instances. It takes the following arguments:\n\nindex: The index for the array.\ncontent: The content of the array.\nparameters: Optional parameters for the array, defaulting to a new Parameters instance.\nbehavior: An optional symbol indicating the behavior, defaulting to :default.\n\n@example  new{INDEX, CONTENT, behavior}(index, content, parameters) The new function is used to create an instance of IndexedArray with the specified fields and type parameters.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.IndexedArray-Union{Tuple{}, Tuple{INDEX}, Tuple{CONTENT}} where {CONTENT<:AwkwardArray.Content, INDEX<:Union{AbstractVector{Int32}, AbstractVector{Int64}, AbstractVector{UInt32}}}","page":"Types","title":"AwkwardArray.IndexedArray","text":"IndexedArray{INDEX,CONTENT}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {INDEX<:IndexBig} where {CONTENT<:Content}\n\nConstructor for the IndexedArray, allowing for the creation of an IndexedArray with default values for its components when specific instances are not provided.\n\nIndexedArray{INDEX, CONTENT}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {INDEX<:IndexBig} where {CONTENT<:Content} =\n    IndexedArray(INDEX([]), CONTENT(), parameters = parameters, behavior = behavior)\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.IndexedOptionArray","page":"Types","title":"AwkwardArray.IndexedOptionArray","text":"IndexedOptionArray{INDEX<:IndexBigSigned, CONTENT<:Content, BEHAVIOR} <: OptionType{BEHAVIOR}\n\nA type of array where elements are indexed and can be optionally present or missing.\n\nstruct IndexedOptionArray{INDEX<:IndexBigSigned, CONTENT<:Content, BEHAVIOR} <: OptionType{BEHAVIOR}\n    index::INDEX\n    content::CONTENT\n    parameters::Parameters\n\n    IndexedOptionArray(\n        index::INDEX,\n        content::CONTENT;\n        parameters::Parameters = Parameters(),\n        behavior::Symbol = :default,\n    ) where {INDEX<:IndexBigSigned, CONTENT<:Content} =\n        new{INDEX, CONTENT, behavior}(index, content, parameters)\nend\n\nType Parameters:\n\nINDEX<:IndexBigSigned: The INDEX type parameter must be a subtype of IndexBigSigned.\nCONTENT<:Content: The CONTENT type parameter must be a subtype of Content.\nBEHAVIOR: A type parameter without constraints, allowing flexibility in specifying behavior.\n\nFields:\n\nindex::INDEX: Holds the index values, which determine the presence or absence of elements.\ncontent::CONTENT: Holds the actual data elements.\nparameters::Parameters: Holds any additional parameters or metadata associated with the array.\n\nConstructor:\n\nThe inner constructor IndexedOptionArray takes three arguments: index, content, and optionally parameters and behavior. Default values are provided for parameters (Parameters()) and behavior (:default). The constructor uses new{INDEX, CONTENT, behavior}(index, content, parameters) to create an instance of IndexedOptionArray with the specified types and values.\n\nInheritance:\n\n<: OptionType{BEHAVIOR} means that IndexedOptionArray is a subtype of OptionType{BEHAVIOR}. This indicates that it is a specialized form of OptionType designed to handle optional or nullable data.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.IndexedOptionArray-Union{Tuple{}, Tuple{INDEX}, Tuple{CONTENT}} where {CONTENT<:AwkwardArray.Content, INDEX<:Union{AbstractVector{Int32}, AbstractVector{Int64}}}","page":"Types","title":"AwkwardArray.IndexedOptionArray","text":"IndexedOptionArray{INDEX,CONTENT}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {INDEX<:IndexBigSigned} where {CONTENT<:Content}\n\nConstructor for the IndexedOptionArray with default values for its parameters and behavior. \n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.LeafType","page":"Types","title":"AwkwardArray.LeafType","text":"LeafType{BEHAVIOR} <: Content{BEHAVIOR}\n\nAbstract type LeafType inherits from Content and is parameterized  by BEHAVIOR. \n\nThis allows to create a flexible and hierarchical type system where  different kinds of content can be represented, and specific behaviors  can be parameterized.\n\nnote: Note\nAll Python NumpyArrays have to be converted to 1-dimensional (inner_shape == ()) with RegularArrays when converting to Julia.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.ListArray","page":"Types","title":"AwkwardArray.ListArray","text":"ListArray{INDEX<:IndexBig,CONTENT<:Content,BEHAVIOR} <: ListType{BEHAVIOR}\n\nAn array of variable-length lists, where the lengths and positions of the lists are specified by starts and stops indices.\n\nType Parameters:\n\nINDEX<:IndexBig: This ensures that the type INDEX is a subtype of IndexBig.\nCONTENT<:Content: This ensures that the type CONTENT is a subtype of Content.\nBEHAVIOR: This parameter allows for any type and is used to specify the behavior of the ListArray.\n\nFields:\n\nstarts::INDEX: An index specifying the starting positions of the lists within the content.\nstops::INDEX: An index specifying the stopping positions of the lists within the content.\ncontent::CONTENT: The actual content of the array, which contains the elements of the lists.\nparameters::Parameters: Additional parameters that can provide metadata or other information.\n\nConstructor:\n\nThe primary constructor initializes a ListArray with given starts, stops indices, and content. parameters::Parameters = Parameters(): This sets a default value for parameters if it is not provided when the constructor is called. behavior::Symbol = :default: This sets a default value for behavior if it is not provided when the constructor is called.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.ListArray-Union{Tuple{}, Tuple{INDEX}, Tuple{CONTENT}, Tuple{BEHAVIOR}} where {BEHAVIOR, CONTENT<:AwkwardArray.Content, INDEX<:Union{AbstractVector{Int32}, AbstractVector{Int64}, AbstractVector{UInt32}}}","page":"Types","title":"AwkwardArray.ListArray","text":"ListArray{INDEX,CONTENT,BEHAVIOR}(;\n    parameters::Parameters = Parameters(),\n) where {INDEX<:IndexBig} where {CONTENT<:Content} where {BEHAVIOR}\n\nConstructor of a ListArray with default parameters, initializing the starts, stops and content with default values.\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.ListArray-Union{Tuple{}, Tuple{INDEX}, Tuple{CONTENT}} where {CONTENT<:AwkwardArray.Content, INDEX<:Union{AbstractVector{Int32}, AbstractVector{Int64}, AbstractVector{UInt32}}}","page":"Types","title":"AwkwardArray.ListArray","text":"ListArray{INDEX,CONTENT}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {INDEX<:IndexBig} where {CONTENT<:Content}\n\nConstructor of a ListArray with default parameters, initializing the starts, stops, content and behavior with default values.\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.ListOffsetArray","page":"Types","title":"AwkwardArray.ListOffsetArray","text":"ListOffsetArray{INDEX<:IndexBig,CONTENT<:Content,BEHAVIOR} <: ListType{BEHAVIOR}\n\nA specialized array to represent variable-length lists within a larger array.\n\nType Parameters:\n\nINDEX<:IndexBig: Defines a type parameter INDEX which is constrained to subtypes of IndexBig. IndexBig typically refers to integer types capable of holding large indices, such as Int32 or Int64.\nCONTENT<:Content: Defines a type parameter CONTENT which is constrained to subtypes of Content.\nBEHAVIOR: A type parameter for behavior, used to define specialized behaviors or metadata associated with the array.\n\nInheritance:\n\n<: ListType{BEHAVIOR}: Indicates that ListOffsetArray is a subtype of ListType.\n\nFields:\n\noffsets::INDEX: An array of offsets that indicate the start of each sublist within the content array. The length of this array is one more than the number of sublists, with the last element pointing to the end of the last sublist.\ncontent::CONTENT: The actual data stored in the array. This can be any kind of array or list of elements.\nparameters::Parameters: A structure to hold additional parameters or metadata associated with the array.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.ListOffsetArray-Union{Tuple{}, Tuple{INDEX}, Tuple{CONTENT}, Tuple{BEHAVIOR}} where {BEHAVIOR, CONTENT<:AwkwardArray.Content, INDEX<:Union{AbstractVector{Int32}, AbstractVector{Int64}, AbstractVector{UInt32}}}","page":"Types","title":"AwkwardArray.ListOffsetArray","text":"ListOffsetArray{INDEX,CONTENT,BEHAVIOR}(;\n    parameters::Parameters = Parameters(),\n) where {INDEX<:IndexBig} where {CONTENT<:Content} where {BEHAVIOR}\n\nConstructor of a ListOffsetArray with default parameters, initializing the offsets and content with default values.\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.ListOffsetArray-Union{Tuple{}, Tuple{INDEX}, Tuple{CONTENT}} where {CONTENT<:AwkwardArray.Content, INDEX<:Union{AbstractVector{Int32}, AbstractVector{Int64}, AbstractVector{UInt32}}}","page":"Types","title":"AwkwardArray.ListOffsetArray","text":"ListOffsetArray{INDEX,CONTENT}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {INDEX<:IndexBig} where {CONTENT<:Content}\n\nConstructor of a ListOffsetArray with default parameters, initializing the offsets, content and behavior with default values.\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.ListType","page":"Types","title":"AwkwardArray.ListType","text":"ListType{BEHAVIOR} <: Content{BEHAVIOR}\n\nAbstract type ListType inherits from Content and is parameterized  by BEHAVIOR. \n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.OptionType","page":"Types","title":"AwkwardArray.OptionType","text":"OptionType{BEHAVIOR} <: Content{BEHAVIOR}\n\nAbstract type that serves as a base for other types representing optional or nullable data.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.Parameters","page":"Types","title":"AwkwardArray.Parameters","text":"Parameters\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.Parameters-Tuple{Vararg{Pair{String}}}","page":"Types","title":"AwkwardArray.Parameters","text":"Parameters(pairs::Vararg{Pair{String,<:Any}})\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.Parameters-Tuple{}","page":"Types","title":"AwkwardArray.Parameters","text":"Parameters()\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.PrimitiveArray","page":"Types","title":"AwkwardArray.PrimitiveArray","text":"PrimitiveArray{ITEM,BUFFER<:AbstractVector{ITEM},BEHAVIOR} <: LeafType{BEHAVIOR}\n\nA specialized array type designed to handle primitive data types with  additional parameters and behaviors.\n\nType Parameters:\n\nITEM: Represents the type of the elements stored in the array.\nBUFFER<:AbstractVector{ITEM}: Constrains BUFFER to be a subtype of AbstractVector that holds items of type ITEM.\nBEHAVIOR: A type parameter that can represent different behaviors associated with the array.\n\nInheritance:\n\n<: LeafType{BEHAVIOR}: Indicates that PrimitiveArray is a subtype of LeafType parameterized by BEHAVIOR.\n\nFields:\n\ndata::BUFFER: The main storage for the array, constrained to be an AbstractVector of ITEM.\nparameters::Parameters: Additional parameters associated with the array, presumably defined elsewhere in the code.\n\nConstructor:\n\nPrimitiveArray(data::BUFFER; parameters::Parameters = Parameters(), behavior::Symbol = :default) where {ITEM,BUFFER<:AbstractVector{ITEM}}: This is the inner constructor for the PrimitiveArray struct. It initializes a new instance of PrimitiveArray with the given data and optional parameters and behavior. The where {ITEM,BUFFER<:AbstractVector{ITEM}} clause ensures that ITEM and BUFFER satisfy the specified constraints.\n\nnew{ITEM,BUFFER,behavior}(data, parameters) creates a new instance of PrimitiveArray with the specified type parameters and field values.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.PrimitiveArray-Union{Tuple{}, Tuple{BEHAVIOR}, Tuple{BUFFER}, Tuple{ITEM}} where {ITEM, BUFFER<:AbstractVector{ITEM}, BEHAVIOR}","page":"Types","title":"AwkwardArray.PrimitiveArray","text":"PrimitiveArray{ITEM,BUFFER,BEHAVIOR}(;\n    parameters::Parameters = Parameters(),\n) where {ITEM,BUFFER<:AbstractVector{ITEM},BEHAVIOR}\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.PrimitiveArray-Union{Tuple{}, Tuple{BUFFER}, Tuple{ITEM}} where {ITEM, BUFFER<:AbstractVector{ITEM}}","page":"Types","title":"AwkwardArray.PrimitiveArray","text":"PrimitiveArray{ITEM,BUFFER}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {ITEM,BUFFER<:AbstractVector{ITEM}}\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.PrimitiveArray-Union{Tuple{}, Tuple{ITEM}} where ITEM","page":"Types","title":"AwkwardArray.PrimitiveArray","text":"PrimitiveArray{ITEM}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {ITEM}\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.Record","page":"Types","title":"AwkwardArray.Record","text":"Record{FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR}\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.RecordArray","page":"Types","title":"AwkwardArray.RecordArray","text":"RecordArray{FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR} <:Content{BEHAVIOR}\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.RecordArray-Union{Tuple{NamedTuple{FIELDS, CONTENTS}}, Tuple{CONTENTS}, Tuple{FIELDS}} where {FIELDS, CONTENTS<:Tuple{Vararg{AwkwardArray.Content}}}","page":"Types","title":"AwkwardArray.RecordArray","text":"RecordArray(\n    contents::NamedTuple{FIELDS,CONTENTS};\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.RecordArray-Union{Tuple{}, Tuple{CONTENTS}, Tuple{FIELDS}} where {FIELDS, CONTENTS<:Tuple{Vararg{AwkwardArray.Content}}}","page":"Types","title":"AwkwardArray.RecordArray","text":"RecordArray{FIELDS,CONTENTS}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {FIELDS,CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.RegularArray","page":"Types","title":"AwkwardArray.RegularArray","text":"RegularArray{CONTENT<:Content,BEHAVIOR} <: ListType{BEHAVIOR}\n\nA multidimensional array with a fixed size for each dimension, where the overall length of the array is determined by the size of its content and the specified size per dimension.\n\nType Parameters:\n\nCONTENT<:Content: Ensures that the type CONTENT is a subtype of Content.\nBEHAVIOR: This parameter can be any type and is used to specify the behavior of the RegularArray.\n\nFields:\n\ncontent::CONTENT: The actual content of the array, which contains the elements.\nsize::Int64: The fixed size for each dimension of the array.\nlength::Int64: The total length of the array, calculated based on the content length and size.\nparameters::Parameters: Additional parameters that can provide metadata or other information.\n\nConstructor:\n\nThe constructor initializes a RegularArray with the given content and size. zeros_length::Int = 0: This sets a default value for the zeros_length parameter if it is not provided. parameters::Parameters = Parameters(): This sets a default value for parameters if it is not provided. behavior::Symbol = :default: This sets a default value for behavior if it is not provided. The length of the array is calculated as zeros_length if size is 0, otherwise it is calculated as the integer division of the length of content by size.\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.RegularArray-Union{Tuple{Int64}, Tuple{CONTENT}} where CONTENT<:AwkwardArray.Content","page":"Types","title":"AwkwardArray.RegularArray","text":"RegularArray{CONTENT}(\n    size::Int;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {CONTENT<:Content}\n\nConstructor of a RegularArray with default parameters, initializing the behavior and content with default values.\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.RegularArray-Union{Tuple{}, Tuple{BEHAVIOR}, Tuple{CONTENT}} where {CONTENT<:AwkwardArray.Content, BEHAVIOR}","page":"Types","title":"AwkwardArray.RegularArray","text":"RegularArray{CONTENT,BEHAVIOR}(;\n    parameters::Parameters = Parameters(),\n) where {CONTENT<:Content,BEHAVIOR}\n\nConstructor of a RegularArray with default parameters, initializing the size and content with default values.\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.RegularArray-Union{Tuple{}, Tuple{CONTENT}} where CONTENT<:AwkwardArray.Content","page":"Types","title":"AwkwardArray.RegularArray","text":"RegularArray{CONTENT}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {CONTENT<:Content}\n\nConstructor of a RegularArray with default parameters, initializing the size, behavior and content with default values.\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.SlotRecord","page":"Types","title":"AwkwardArray.SlotRecord","text":"SlotRecord{CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR}\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.Specialization","page":"Types","title":"AwkwardArray.Specialization","text":"Specialization{ARRAY<:UnionArray,TAGGED<:Content}\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.Specialization-Tuple{AwkwardArray.UnionArray, Int64}","page":"Types","title":"AwkwardArray.Specialization","text":"Specialization(layout::UnionArray, tag::Int)\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.TupleArray","page":"Types","title":"AwkwardArray.TupleArray","text":"TupleArray{CONTENTS<:Base.Tuple{Vararg{Content}},BEHAVIOR} <:\n            Content{BEHAVIOR}\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.TupleArray-Tuple{CONTENTS} where CONTENTS<:Tuple{Vararg{AwkwardArray.Content}}","page":"Types","title":"AwkwardArray.TupleArray","text":"TupleArray(\n    contents::CONTENTS;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.TupleArray-Union{Tuple{}, Tuple{CONTENTS}} where CONTENTS<:Tuple{Vararg{AwkwardArray.Content}}","page":"Types","title":"AwkwardArray.TupleArray","text":"TupleArray{CONTENTS}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {CONTENTS<:Base.Tuple{Vararg{Content}}}\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.UnionArray","page":"Types","title":"AwkwardArray.UnionArray","text":"UnionArray{\n    TAGS<:Index8,\n    INDEX<:IndexBig,\n    CONTENTS<:Base.Tuple{Vararg{Content}},\n    BEHAVIOR,\n} <: Content{BEHAVIOR}\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.UnionArray-Union{Tuple{CONTENTS}, Tuple{INDEX}, Tuple{TAGS}} where {TAGS<:AbstractVector{Int8}, INDEX<:Union{AbstractVector{Int32}, AbstractVector{Int64}, AbstractVector{UInt32}}, CONTENTS<:Tuple{Vararg{AwkwardArray.Content}}}","page":"Types","title":"AwkwardArray.UnionArray","text":"UnionArray{TAGS,INDEX,CONTENTS}(\n    contents::CONTENTS;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n)\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.UnionArray-Union{Tuple{}, Tuple{CONTENTS}, Tuple{INDEX}, Tuple{TAGS}} where {TAGS<:AbstractVector{Int8}, INDEX<:Union{AbstractVector{Int32}, AbstractVector{Int64}, AbstractVector{UInt32}}, CONTENTS<:Tuple{Vararg{AwkwardArray.Content}}}","page":"Types","title":"AwkwardArray.UnionArray","text":"UnionArray{TAGS,INDEX,CONTENTS}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n)\n\n\n\n\n\n","category":"method"},{"location":"types/#AwkwardArray.UnmaskedArray","page":"Types","title":"AwkwardArray.UnmaskedArray","text":"UnmaskedArray{CONTENT<:Content,BEHAVIOR} <: OptionType{BEHAVIOR}\n\n\n\n\n\n","category":"type"},{"location":"types/#AwkwardArray.UnmaskedArray-Union{Tuple{}, Tuple{CONTENT}} where CONTENT<:AwkwardArray.Content","page":"Types","title":"AwkwardArray.UnmaskedArray","text":"UnmaskedArray{CONTENT}(;\n    parameters::Parameters = Parameters(),\n    behavior::Symbol = :default,\n) where {CONTENT<:Content}\n\n\n\n\n\n","category":"method"},{"location":"types/#Examples","page":"Types","title":"Examples","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"julia> using AwkwardArray: StringOffsetArray\n\njulia> array = StringOffsetArray()\n0-element ListOffsetArray{Vector{Int64}, PrimitiveArray{UInt8, Vector{UInt8}, :char}, :string}\n\njulia> append!(array, [\"one\", \"two\", \"three\", \"four\", \"five\"])\n5-element ListOffsetArray{Vector{Int64}, PrimitiveArray{UInt8, Vector{UInt8}, :char}, :string}:\n \"one\"\n \"two\"\n \"three\"\n \"four\"\n \"five\"\n\njulia> array[3]\n\"three\"\n\njulia> typeof(array[3])\nString","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Most applications of behavior apply to RecordArrays (e.g. Vector in Python).","category":"page"},{"location":"types/#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"}]
}
